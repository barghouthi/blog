---
title: "A Quantum Circuit Simulator in 25 Lines of Python"
layout: post
---

Today we’re going to write a quantum circuit interpreter (or *simulator*) using just 25 lines of Python. 

To understand this post, all you need to know is matrix multiplication. I’ll walk you through the rest! We’re going to treat operations of a quantum computer as yet another programming language for which we want to build an interpreter. So we won’t get into quantum mechanics or fancy quantum algorithms.

---

## Classical circuits
We will begin by writing an interpreter for classical circuits—you know, *not*, *and*, *or*. Then, we will generalize our interpreter to quantum circuits. A classical circuit in our setting applies logical operations to $n$ bits. 

### Classical state
Let’s begin by representing the state of $n$ bits. We’ll do this in an unusual way. We will define a vector of size $2^n$ where each index of the vector represents one possible configuration of the $n$ bits. 
For $n=1$ we have a vector of size 2, e.g.:

<img src="{{site.url}}/assets/classic1.png" alt="drawing" width="300"/>

The vector is in black; the numbers in pink (left) are the indices. The vector above therefore represents that the bit is 1, since at index 1 
we have a have 1.
Similarly the vector 
$$\begin{bmatrix}
           1\\0
\end{bmatrix}$$
denotes that the bit is 0.

For $n=2$, we have a vector of size 4, like the following, which denotes that both bits are 0.

<img src="{{site.url}}/assets/classic2.png" alt="drawing" width="400"/>


You get the idea. It’s a terribly inefficient representation, but I chose it on purpose because we’ll later generalize it to *qubits* and quantum simulation is inherently inefficient as far as we can tell.

Here's a Python class to represent a classical state with $n$ bits.
Note that a `state` is initialized to all 0s.
Also, note that we're using numpy (`np`)

```python
class Cstate:
  def __init__(self, n):
    self.n = n
    self.state = np.zeros(2**self.n, dtype=np.int)
    self.state[0] = 1 #initialize bits to 0s
```
For example, `state` for a 2 bits initially looks like this:
```python
[1 0 0 0]
```
Note that numpy represents vectors as rows instead of our column vectors above---it won't make a difference for us.

### Negating a bit
Let's now apply a NOT (negation) operation to a bit.
In a circuit of 1 bit this looks as follows
(where the pink stuff is an example input/output of the circuit):

<img src="{{site.url}}/assets/not1.png" alt="drawing" width="400"/>

NOT is a transformation that takes a bit from one state to another.
We're going to represent it as a transformation matrix, as follows:

<img src="{{site.url}}/assets/notmat.png" alt="drawing" width="300"/>

The way to read the matrix is by looking at columns then rows.
Note that each column has a single 1, and the rest of the entries are 0s.
The position of the 1 denotes the transformation.
Take the bottom left 1 in the matrix, which is at column 0 and row 1;
this means that a bit that is 0 is transformed into 1.
Take the top right 1 now, at column 1 and row 0;
this means that a bit that is 1 is transformed into 0.

Now to apply this transformation to a state in our representation,
we simply multiply the NOT matrix above with the state vector.

<img src="{{site.url}}/assets/notmult.png" alt="drawing" width="300"/>

The above multiplication results in 
$$\begin{bmatrix}
           0\\1
\end{bmatrix}$$

### Handling multiple bits
But what happens when we have $n$ bits and we only want to negate
a specific one, say the $i$th one?

<img src="{{site.url}}/assets/noti.png" alt="drawing" width="300"/>

We will construct a bigger transformation matrix that only applies
the NOT to the $i$th bit and leaves the rest untouched.
To do so, we will "compose" the NOT matrix above with two identity matrices.
One identity matrix will say that all bits before bit $i$, i.e., bits $0$ to $i-1$, are untouched;
the other will say that all bits after bit $i$, i.e.,  $i+1$ to $n-1$, are untouched.

Let's first do this for the simple case of two bits
where we want to negate the second bit.
We take the *Kronecker product* ($\otimes$) of the identity matrix (of size 2, denoted $I_2$) with the NOT transformation.

<img src="{{site.url}}/assets/not2.png" alt="drawing" width="300"/>

If you haven't seen Kroenecker product before, don't be scared;
it just multiplies  each element of the left matrix with the entire right matrix.
So in thie case, we get a 4x4 matrix:

<img src="{{site.url}}/assets/not4.png" alt="drawing" width="300"/>

Consider the element highlighted in yellow. It says if the  bits
are 01, then turn them into 00. Note that the second bit flips, but not the first bit. The same can be seen with the element highlighted in pink.

Alright, let's capture this Kronecker product idea in its general form
and implement it.

<img src="{{site.url}}/assets/notg.png" alt="drawing" width="500"/>

We will implement this as a method of the `Cstate` class
that takes an arbitrary transformation matrix over contiguous bits and 
applies it to all the $n$ bits.

```python
def op(self, t, i):
    #I_{2^i}
    eyeL = np.eye(2**i, dtype=np.int)

    #I_{2^{n-i-1}}
    eyeR = np.eye(2**(self.n - i - int(t.shape[0]**0.5)), 
        dtype = np.int)

    # eyeL ⊗ t ⊗ eyeR
    t_all = np.kron(np.kron(eyeL, t), eyeR)

    # apply transformation
    self.state = np.matmul(t_all, self.state)

def NOT(self, i):
    not_matrix = np.array(
        [[0,1],
         [1,0]]
    )
    self.op(not_matrix, i)
```

The method `op` takes a transformation matrix `t`, e.g., the NOT matrix
and applies it the bit `i`.
The `NOT` method calls `op` with the NOT matrix.
Note that `op` also applies to operations that apply to more than 1 bit,
e.g., `AND`, so long as the bits are contiguous.

### Binary operations
Let's now some binary operations.
The following transformation swaps two bits.

<img src="{{site.url}}/assets/swap.png" alt="drawing" width="300"/>

We can implement it as follows.
Note that `swap(i)` swaps the bit `i` and `i+1`.

```python
def swap(self, i):
    swap_matrix = np.array(
        [[1, 0, 0, 0],
         [0, 0, 1, 0],
         [0, 1, 0, 0],
         [0, 0, 0, 1]]
      )
    self.op(swap_matrix, i)
```
As a circuit, a swap is shown like this:

<img src="{{site.url}}/assets/swapc.png" alt="drawing" width="400"/>

We can similarly implement AND and OR, where the result is stored
in the first of the two bits.

<img src="{{site.url}}/assets/andor.png" alt="drawing" width="500"/>

### Simple example
Finally, we end our discussion of classical circuits
with a simple circuit that checks if two bits are both zero.
The result is stored in the first bit.

```python
s = Cstate(2) # initialize state
s.NOT(0) # negate first bit
s.NOT(1) # negate second bit
s.AND(0) # AND first and second bits
print(s.state)
```
We get 
```python
[0 0 0 1]
```
which means that at the end the bits are 11.
Since the first bit is 1, this means that 
the two bits were initially zero.

## Quantum circuits
We now generalize the above to quantum circuits.
Instead of bits, we have *qubits*.
A qubit can be 0, 1 or a superposition of 0 and 1.
So if you write out its vector, it can have numbers in different indices.
E.g.,

<img src="{{site.url}}/assets/qubit.png" alt="drawing" width="300"/>

What this says is that if you *measure* the qubit---read its value---you will read 0 with probability 1/2 and 1 with probability 1/2. The probability is the square of the $1/\sqrt{2}$, the *amplitude*.
Amplitudes can be complex numbers.
The above vector is usually written with the following notation:
$$\frac{1}{\sqrt{2}} |0\rangle + \frac{1}{\sqrt{2}} |1\rangle $$,
with amplitudes multiplied by the classical states, 0 and 1, which are wrapped in $|\cdot\rangle$ for historical reasons.

We can easily represent this state by copy-pasting the class definition
of classical states and changing the types from `int` to `complex`.
Voila! Who said copy-paste is bad?

```python
class Cstate:
  def __init__(self, n):
    self.n = n
    self.state = np.zeros(2**self.n, dtype=np.complex)
    self.state[0] = 1 #initialize bits to 0s
```

### Hadamard gate
Transformations of quantum states are also matrices,
but the matrices can have complex numbers.
The matrices are *unitary*, which means that they are invertible
and maintains that the state represents a probability distribution.
This fact comes from the postulates of quantum mechanics.

The first transformation we'll look at is *Hadamard*, which applies to a single qubit.

<img src="{{site.url}}/assets/hadamard.png" alt="drawing" width="300"/>

A Hadamard gate puts a state in superposition.
For example, given the classical state $|0\rangle$, i.e., the vector $$\begin{bmatrix}
           1\\ 0
\end{bmatrix}$$,
it transforms it into the superposition we saw above, $$\frac{1}{\sqrt{2}} |0\rangle + \frac{1}{\sqrt{2}} |1\rangle $$.
As a circuit, we write this as follows:

<img src="{{site.url}}/assets/hadamard2.png" alt="drawing" width="500"/>

Simiarly, given the state $|1\rangle$, Hadamard
 transforms it into the superposition $$\frac{1}{\sqrt{2}} |0\rangle - \frac{1}{\sqrt{2}} |1\rangle $$.
 Note the negative amplitude.
 This is a key property of quantum mechanics that quantum algorithms exploit,
 allowing amplitudes to cancel out (interfere), which we cannot achieve with classical randomized algorithms. We won't get into it, but I recommend you take a look at [Grover's algorithm](https://quantum.country/search) (which is beautiful).

We will implement Hadamard just as we did with NOT.
I'm using `isq2` as a shorthand for $1/\sqrt{2}$.

```python
# the only difference is dtype, which is np.complex now
def op(self, t, i):
    #I_{2^i}
    eyeL = np.eye(2**i, dtype=np.complex)

    #I_{2^{n-i-1}}
    eyeR = np.eye(2**(self.n - i - int(t.shape[0]**0.5)), 
        dtype = np.complex)

    # eyeL ⊗ t ⊗ eyeR
    t_all = np.kron(np.kron(eyeL, t), eyeR)

    # apply transformation
    self.state = np.matmul(t_all, self.state)

def hadamard(self, i):
    h_matrix = isq2 * np.array(
        [[1,1],
         [1,-1]]
    )    
    self.op(h_matrix, i)
```

### Controlled NOT gate
Next, we'll look at the CNOT gate, which is a binary gate.

<img src="{{site.url}}/assets/cnot.png" alt="drawing" width="300"/>

Classically speaking, this takes the XOR of two bits and stores the result
in the second bit.
But, as we shall see, it is fundamental in quantum computing,
as it allows to *entangle* two quabits.
Pictorially, CNOT is denoted as follows:

<img src="{{site.url}}/assets/cnotc.png" alt="drawing" width="300"/>

We will implement CNOT as follows:

```python
 def cnot(self, i):
    cnot_matrix = np.array(
        [[1, 0, 0, 0],
         [0, 1, 0, 0],
         [0, 0, 0, 1],
         [0, 0, 1, 0]], dtype=np.complex
      )
    self.op(cnot_matrix, i)
```
Qubit swaps are the same as classical bit swaps.

### Phase-shift gates
Finally, we're missing two single-bit gates
that give us the full power of a quantum computer.
By full power this means a *univerasal set of gates* which which we can simulate any unitary transformation
to arbitrary degree of accuracy.

The two missing gates are the $T$ and $S$ gates.

```python
TBD
```

## EPR pairs 

We will end with constructing an *EPR pair*, a special entangled stated of two qubits put forth by Einstein, Podolsky and Rosen in 1935 to argue that quantum mechanics is incomplete.

Here's how the circuit looks. Apply a Hadamard to the first qubit,
putting it in superposition, then apply a CNOT to both qubits.
<img src="{{site.url}}/assets/epr.png" alt="drawing" width="600"/>

This results in the following state, which is called an EPR pair or a *Bell state*:

$$
    \frac{1}{\sqrt{2}} |00\rangle + \frac{1}{\sqrt{2}} |11\rangle
$$

The beauty of this state is that...

Here's how we code it up:
```python
# constructing an EPR pair
s = Qstate(2) # create a 2-qubit state
s.hadamard(0) # hadamard on first qubit
s.cnot(0) # CNOT the two qubits
print(s.state)
```
We get the following output,
which I've simplified for legibility.
(Note that  $1/\sqrt{2} \approx 0.70710678$)

```python
[0.70710678 0 0 0.70710678]
```


## The Entire Quantum Circuit Simulator
Here's the entire code:

```python
import numpy as np

isq2 = 1.0/(2.0**0.5)

class Qstate:
  def __init__(self, n):
    self.n = n
    self.state = np.zeros(2**self.n, dtype=np.complex)
    self.state[0] = 1

  def op(self, m, i):
    eyeL = np.eye(2**i, dtype=np.complex)
    eyeR = np.eye(2**(self.n - i - int(m.shape[0]**0.5)), 
        dtype = np.complex)
    
    left = np.kron(eyeL, m)
    right = np.kron(left, eyeR)

    self.state = np.matmul(right, self.state)

  def t(self, i):
    t_matrix = np.array([[1,0],[0,isq2 + isq2 * 1j]])
    self.op(t_matrix, i)

  def hadamard(self, i):
    h_matrix = isq2 * np.array([[1,1],[1,-1]])    
    self.op(h_matrix, i)

  def phase(self, i):
    phase_matrix = np.array([[1,0],[0,0+1j]], 
        dtype=np.complex)    
    self.op(phase_matrix,i)

  def cnot(self, i):
    cnot_matrix = np.array(
        [[1, 0, 0, 0],
         [0, 1, 0, 0],
         [0, 0, 0, 1],
         [0, 0, 1, 0]], dtype=np.complex
      )
    self.op(cnot_matrix, i)
  
  def swap(self, i):
    swap_matrix = np.array(
        [[1, 0, 0, 0],
         [0, 0, 1, 0],
         [0, 1, 0, 0],
         [0, 0, 0, 1]]
      )
    self.op(swap_matrix, i)
```

## What else
1. measurement