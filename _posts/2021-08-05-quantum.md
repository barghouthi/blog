---
title: "A Quantum Circuit Simulator in 27 Lines of Python"
layout: post
---

Today we’re going to write a quantum circuit interpreter (or *simulator*) using just 27 lines of Python. 

To understand this post, all you need to know is matrix multiplication. I’ll walk you through the rest! We’re going to treat operations of a quantum computer as yet another programming language for which we want to build an interpreter. So we won’t get too much into quantum mechanics or fancy quantum algorithms.

You can find the entire simulator code at the [bottom](#the-entire-quantum-circuit-simulator) of this post,
or as a [notebook](notebook).

---

## Classical circuits
We will begin by writing an interpreter for classical circuits—you know, *not*, *and*, *or*. Then, we will generalize our interpreter to quantum circuits. A classical circuit in our setting applies logical operations to $n$ bits. 

### Classical state
Let’s begin by representing the state of $n$ bits. We’ll do this in an unusual way. We will define a vector of size $2^n$ where each index of the vector represents one possible configuration of the $n$ bits. 
For $n=1$ we have a vector of size 2, e.g.:

<img src="{{site.url}}/assets/classic1.png" alt="drawing" width="300"/>

The vector is in black; the numbers in pink (left) are the indices. The vector above therefore represents that the bit is 1, since at index 1 
we have a have 1.
Similarly the vector 
$$\begin{bmatrix}
           1\\0
\end{bmatrix}$$
denotes that the bit is 0.

For $n=2$, we have a vector of size 4, like the following, which denotes that both bits are 0.

<img src="{{site.url}}/assets/classic2.png" alt="drawing" width="400"/>


You get the idea. It’s a terribly inefficient representation, but I chose it on purpose because we’ll later generalize it to *qubits* and quantum simulation is inherently [inefficient](https://en.wikipedia.org/wiki/BQP) as far as we can tell.

Here's a Python class to represent a classical state with $n$ bits.
Note that a `state` is initialized to all bits being 0.
Also, note that we're using numpy (`np`)

```python
class Cstate:
  def __init__(self, n):
    self.n = n
    self.state = np.zeros(2**self.n, dtype=np.int)
    self.state[0] = 1 #initialize bits to 0s
```
For example, `state` for 2 bits initially looks like this,
denoting the state 00 (just like the 2-bit vector illustrated above)
```python
[1 0 0 0]
```
Note that numpy represents vectors as rows instead of our column vectors above---it won't make a difference for us.

### Flipping a bit
Let's now apply a NOT (negation) operation to a bit.
In a circuit of 1 bit, this looks as follows
(where the pink stuff is an example input/output of the circuit):

<img src="{{site.url}}/assets/not1.png" alt="drawing" width="400"/>

NOT is a transformation that takes a bit from one state to another.
We're going to represent it as a transformation matrix, as follows:

<img src="{{site.url}}/assets/notmat.png" alt="drawing" width="300"/>

The way to read the matrix is by looking at columns then rows.
Note that each column has a single 1  and the rest of the entries are 0s.
The position of the 1 denotes the transformation.
Take the bottom left 1 in the matrix, which is at column 0 and row 1;
this means that a bit that is 0 is transformed into 1.
Take the top right 1 now, at column 1 and row 0;
this means that a bit that is 1 is transformed into 0.

Now to apply this transformation to a state in our representation,
we simply multiply the NOT matrix above with the state vector.
For example, we can apply it to the a single bit set to 0:

<img src="{{site.url}}/assets/notmult.png" alt="drawing" width="300"/>

The above multiplication results in 
$$\begin{bmatrix}
           0\\1
\end{bmatrix}$$, denoting a bit set to 1.

### Handling multiple bits
But what happens when we have $n$ bits and we only want to negate
a specific one, say the $i$th one?

<img src="{{site.url}}/assets/noti.png" alt="drawing" width="300"/>

We will construct a bigger transformation matrix that only applies
the NOT to the $i$th bit and leaves the rest untouched.
To do so, we will "compose" the NOT matrix above with two identity matrices.
One identity matrix will say that all bits before bit $i$ (bits $0$ to $i-1$) are untouched;
the other will say that all bits after bit $i$  (bits $i+1$ to $n-1$) are untouched.

Let's first do this for the simple case of two bits
where we want to negate the second bit.
We take the *Kronecker product* ($\otimes$) of the identity matrix (of size 2, denoted $I_2$) with the NOT transformation.

<img src="{{site.url}}/assets/not2.png" alt="drawing" width="300"/>

If you haven't seen Kroenecker product before, don't be scared;
it just multiplies  each element of the left matrix with the entire right matrix.
So in this case, we get a 4x4 matrix as follows:


<img src="{{site.url}}/assets/not4.png" alt="drawing" width="300"/>
Look at the 2x2 sub-matrix on the top left:
It's the result of multiplying 1 (the top-left element of $I_2$) with the NOT matrix.

Consider the element highlighted in yellow. It says if the  bits
are 01 (column), then turn them into 00 (row). Note that the second bit flips, but not the first bit. The same can be seen with the element highlighted in pink.

Alright, let's capture this Kronecker product idea in its general form
and implement it.
 $I_m$ means an indentity matrix that of size $m \times m$.

<img src="{{site.url}}/assets/notg.png" alt="drawing" width="500"/>

We will implement this as a method of the `Cstate` class
that takes an arbitrary transformation `t` matrix over contiguous bits and 
applies it to all  $n$ bits.

```python
def op(self, t, i):
    #I_{2^i}
    eyeL = np.eye(2**i, dtype=np.int)

    #I_{2^{n-i-1}}
    eyeR = np.eye(2**(self.n - i - int(t.shape[0]**0.5)), 
        dtype = np.int)

    # eyeL ⊗ t ⊗ eyeR
    t_all = np.kron(np.kron(eyeL, t), eyeR)

    # apply transformation to state
    self.state = np.matmul(t_all, self.state)

def NOT(self, i):
    not_matrix = np.array([
        [0,1],
        [1,0]
    ])
    self.op(not_matrix, i)
```

The method `op` takes a transformation matrix `t`, e.g., the NOT matrix,
and applies it to the bit `i`.
The `NOT` method calls `op` with the NOT matrix.
Note that `op` also applies to operations that apply to more than 1 bit,
e.g., `AND`, so long as the bits are contiguous.

### Binary operations
Let's now look at some binary operations.
The following transformation swaps two bits.

<img src="{{site.url}}/assets/swap.png" alt="drawing" width="300"/>

We can implement it as follows.
Note that `swap(i)` swaps bits `i` and `i+1`.

```python
def swap(self, i):
    swap_matrix = np.array([
        [1, 0, 0, 0],
        [0, 0, 1, 0],
        [0, 1, 0, 0],
        [0, 0, 0, 1]
    ])
    self.op(swap_matrix, i)
```
As a circuit, a swap is shown like this:

<img src="{{site.url}}/assets/swapc.png" alt="drawing" width="400"/>

We can similarly implement AND and OR, where the result is stored
in the first of the two bits.
<img src="{{site.url}}/assets/andor.png" alt="drawing" width="600"/>

### Simple example
Finally, we end our discussion of classical circuits
with a simple circuit that checks if two bits are both zero.
The result is stored in the first bit.

```python
s = Cstate(2) # initialize state
s.NOT(0) # negate first bit
s.NOT(1) # negate second bit
s.AND(0) # AND first and second bits

print(s.state)
```
We get 
```python
[0 0 0 1]
```
which means that at the end the bits are 11.
Since the first bit is 1, this means that 
the two bits were initially zero.

## Quantum circuits
We now generalize the above to quantum circuits.
Instead of bits, we have *qubits*.
A qubit can be 0, 1, or a superposition of 0 and 1.
So if you write out its vector, it can have numbers in different indices.
E.g.,

<img src="{{site.url}}/assets/qubit.png" alt="drawing" width="300"/>

What this says is that if you *measure* the qubit---read its value---you will read 0 with probability 1/2 and 1 with probability 1/2. The probability is the square of $1/\sqrt{2}$, the *amplitude*.
Amplitudes can be complex numbers.

The above vector is usually written with the following notation:
$$\frac{1}{\sqrt{2}} |0\rangle + \frac{1}{\sqrt{2}} |1\rangle $$,
with amplitudes multiplied by the classical states, 0 and 1, which are wrapped in $|\cdot\rangle$ for historical reasons.

We can easily represent this state by copy-pasting the class definition
of classical states and changing the types from `int` to `complex`.
Voila! Who said copy-paste is bad?

```python
class Qstate:
  def __init__(self, n):
    self.n = n
    self.state = np.zeros(2**self.n, dtype=np.complex)
    self.state[0] = 1 #initialize bits to 0s
```

### Hadamard gate
Transformations of quantum states are also matrices,
but the matrices can have complex numbers.
The matrices are *unitary*, which means that they are invertible
and maintain that the state represents a probability distribution.
This fact comes from the postulates of quantum mechanics.

The first transformation we'll look at is *Hadamard*, which applies to a single qubit.

<img src="{{site.url}}/assets/hadamard.png" alt="drawing" width="300"/>

A Hadamard gate puts a state in superposition.
For example, given the classical state $|0\rangle$, i.e., the vector $$\begin{bmatrix}
           1\\ 0
\end{bmatrix}$$,
it transforms it into the superposition we saw above, $$\frac{1}{\sqrt{2}} |0\rangle + \frac{1}{\sqrt{2}} |1\rangle $$.
As a circuit, we write this as follows:

<img src="{{site.url}}/assets/hadamard2.png" alt="drawing" width="500"/>

Simiarly, given the state $|1\rangle$, Hadamard
 transforms it into the superposition $$\frac{1}{\sqrt{2}} |0\rangle - \frac{1}{\sqrt{2}} |1\rangle $$.
 Note the negative amplitude.
 This is a key property of quantum mechanics that quantum algorithms exploit,
 allowing amplitudes to cancel out (interfere), which we cannot achieve with classical randomized algorithms. We won't get into it, but I recommend you take a look at [Grover's algorithm](https://quantum.country/search) (which is beautiful).

We will implement Hadamard just as we did with NOT.
I'm using `isq2` as a shorthand for $1/\sqrt{2}$.

```python
# the only difference is dtype, which is np.complex now
def op(self, t, i):
    #I_{2^i}
    eyeL = np.eye(2**i, dtype=np.complex)

    #I_{2^{n-i-1}}
    eyeR = np.eye(2**(self.n - i - int(t.shape[0]**0.5)), 
        dtype = np.complex)

    # eyeL ⊗ t ⊗ eyeR
    t_all = np.kron(np.kron(eyeL, t), eyeR)

    # apply transformation to state
    self.state = np.matmul(t_all, self.state)

def hadamard(self, i):
    h_matrix = isq2 * np.array(
        [[1,1],
         [1,-1]]
    )    
    self.op(h_matrix, i)
```

### Controlled NOT gate
Next, we'll look at the CNOT gate, which is a binary gate.

<img src="{{site.url}}/assets/cnot.png" alt="drawing" width="300"/>

Classically speaking, this takes the XOR of two bits and stores the result
in the second bit.
But, as we shall see, it is fundamental in quantum computing,
as it allows us to *entangle* two qubits (more on this in a bit).
Pictorially, CNOT is denoted as follows:

<img src="{{site.url}}/assets/cnotc.png" alt="drawing" width="300"/>

We will implement CNOT as follows---again, just like 
in the classical setting:

```python
 def cnot(self, i):
    cnot_matrix = np.array(
        [[1, 0, 0, 0],
         [0, 1, 0, 0],
         [0, 0, 0, 1],
         [0, 0, 1, 0]], dtype=np.complex
      )
    self.op(cnot_matrix, i)
```
Qubit swaps are the same as classical bit swaps.

### Phase-shift gates
Finally, we're missing two single-bit gates
that give us the full power of a quantum computer.
By full power this means a *univerasal set of gates* which which we can simulate any unitary transformation
to arbitrary degree of accuracy.

The two missing gates are the $T$ and $S$ gates.

```python
TBD
```

## EPR pairs 

We will end with constructing an *EPR pair*, a special entangled stated of two qubits put forth by Einstein, Podolsky and Rosen in 1935 to argue that quantum mechanics is incomplete.

Here's how the circuit looks. Apply a Hadamard to the first qubit,
putting it in superposition, then apply a CNOT to both qubits.
<img src="{{site.url}}/assets/epr.png" alt="drawing" width="600"/>

This results in the following state, which is called an EPR pair or a *Bell state*:

$$
    \frac{1}{\sqrt{2}} |00\rangle + \frac{1}{\sqrt{2}} |11\rangle
$$

In vector notation, an EPR pair is
<img src="{{site.url}}/assets/epr2.png" alt="drawing" width="200"/>


The beauty of this state is that the two qubits are entangled.
This means if we measure the first bit, we will get 0 or 1 
with equal probability.
But then the other qubit will also *collapse* to the same
answer that we get.
So if each of us has one of the two entangled bits,
it appears that we can achieve instantaneous communication!
This didn't sit well with Einstein and his friends;
indeed, they're construction of EPR pairs was to show a paradox.
EPR pairs are key ingredients in [quantum teleportation](https://quantum.country/teleportation), which I encourage you to read about.

Here's how we construct an EPR pair with our interpreter.
```python
# constructing an EPR pair
s = Qstate(2) # create a 2-qubit state
s.hadamard(0) # hadamard on first qubit
s.cnot(0) # CNOT the two qubits

print(s.state)
```
We get the following output,
which I've simplified for legibility.
(Note that  $1/\sqrt{2} \approx 0.70710678$)

```python
[0.70710678   0   0   0.70710678]
```



## The Entire Quantum Circuit Simulator
Here's the entire 27 lines of code.

```python
import numpy as np

isq2 = 1.0/(2.0**0.5)

class Qstate:
  def __init__(self, n):
    self.n = n
    self.state = np.zeros(2**self.n, dtype=np.complex)
    self.state[0] = 1

  # the only difference is dtype, which is np.complex now
  def op(self, t, i):
    #I_{2^i}
    eyeL = np.eye(2**i, dtype=np.complex)

    #I_{2^{n-i-1}}
    eyeR = np.eye(2**(self.n - i - int(t.shape[0]**0.5)), 
        dtype = np.complex)

    # eyeL ⊗ t ⊗ eyeR
    t_all = np.kron(np.kron(eyeL, t), eyeR)

    # apply transformation to state
    self.state = np.matmul(t_all, self.state)

  # Hadamard gate
  def hadamard(self, i):
    h_matrix = isq2 * np.array([
        [1,1],
        [1,-1]
    ])    
    self.op(h_matrix, i)

  # T gate
  def t(self, i):
    t_matrix = np.array([
        [1,0],
        [0,isq2 + isq2 * 1j]
    ])
    self.op(t_matrix, i)

  # S gate
  def s(self, i):
    phase_matrix = np.array([
        [1,0],
        [0,0+1j]
    ], dtype=np.complex)    
    self.op(phase_matrix,i)

  # CNOT gate
  def cnot(self, i):
    cnot_matrix = np.array([
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, 0, 1],
        [0, 0, 1, 0]
    ])
    self.op(cnot_matrix, i)
  
  # Swap two qubits
  def swap(self, i):
    swap_matrix = np.array([
        [1, 0, 0, 0],
        [0, 0, 1, 0],
        [0, 1, 0, 0],
        [0, 0, 0, 1]
    ])
    self.op(swap_matrix, i)
```

## Notes
1. Our simulator doesn't implement measurement,
because it represents the entire probability distribution explicitly.
2. As an introduction to quantum computing, I recomment Matuschak and Nielsen's [Quantum Country](https://quantum.country/).
3. Our binary gates apply to contiguous (qu)bits.
This makes them the `op` function simpler to write. We can generalize the `op` function to apply binary gates to any pair of (qu)bits, but it gets a bit uglier. Since we have `swap`, we can always move qubits next to each other.