<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title></title>
 <link href="http://localhost:4000/atom.xml" rel="self"/>
 <link href="http://localhost:4000/"/>
 <updated>2019-07-17T11:48:51-05:00</updated>
 <id>http://localhost:4000</id>
 <author>
   <name>Aws Albarghouthi</name>
   <email>albargah@gmail.com</email>
 </author>

 
 <entry>
   <title>Teaching Your SMT Solver Probability Theory</title>
   <link href="http://localhost:4000/2019/07/15/smt-probability/"/>
   <updated>2019-07-15T00:00:00-05:00</updated>
   <id>http://localhost:4000/2019/07/15/smt-probability</id>
   <content type="html">&lt;p&gt;The unexpected rise of SAT and SMT solvers has revolutionized software verification, both the automated and deductive flavors.
Simply, you encode program semantics as logical circuits and ask the SMT solver questions about them. How elegant.
But what happens when your program is randomized? Good luck! The first-order world of SMT solvers does not have the ingredients to sustain your stochastic existence. Go find another home.&lt;/p&gt;

&lt;p&gt;In this post, I will show you how to teach your SMT solver probability theory.
The ideas here are a simplified view of a recent &lt;a href=&quot;http://pages.cs.wisc.edu/~aws/papers/popl19.pdf&quot;&gt;POPL paper&lt;/a&gt; by my student &lt;a href=&quot;http://pages.cs.wisc.edu/~cjsmith/&quot;&gt;Calvin Smith&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;classical-verification&quot;&gt;Classical verification&lt;/h2&gt;

&lt;p&gt;To ground things, I will start with a classical (non-probabilistic) verification problem and encode it as a formula in first-order logic.
Take this program:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If we’re working with infinite-precision integers, the following Hoare triple is valid — a positive input results in a positive output.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\vdash \{x &gt; 0\}  ~f(x)~ \{y &gt; 0\}&lt;/script&gt;

&lt;p&gt;To formally prove that this Hoare triple holds, we encode the precondition, postcondition, and program semantics as the following formula:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(\underbrace{x &gt; 0}_{\text{pre}} \land \underbrace{z = x + 1 \land y = z * 2}_{\text{encoding of } f \ (\text{strongest post})}) \Longrightarrow \underbrace{y &gt; 0}_{\text{post}}&lt;/script&gt;

&lt;p&gt;If the SMT solver tells you that the formula is valid, then the Hoare triple is valid. If it’s not valid, the SMT solver will give you a counterexample.&lt;/p&gt;

&lt;h2 id=&quot;randomized-algorithm-example&quot;&gt;Randomized algorithm example&lt;/h2&gt;

&lt;p&gt;Let’s now look at a very simple randomized program, where &lt;code class=&quot;highlighter-rouge&quot;&gt;uniform(a,b)&lt;/code&gt; returns a sample from the uniform distribution between values &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uniform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Say we want to prove the following (probabilistic) Hoare triple:&lt;sup id=&quot;fnref:union-bound&quot;&gt;&lt;a href=&quot;#fn:union-bound&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\vdash_{\color{red}{1/3}} \{x &gt; 0\}  ~f(x)~ \{y \geq x\}&lt;/script&gt;

&lt;p&gt;Let’s unpack this: If $x$ is positive, then $f$ returns a value of $y \geq x$, &lt;em&gt;but&lt;/em&gt; there is at most a $\color{red}{1/3}$ probability of failure.&lt;/p&gt;

&lt;p&gt;This Hoare triple is intuitively valid: values of $y$ are uniformly distributed between $0$ and $3x$, so getting a value of $y \geq x$ has a failure probability of $1/3$.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/probability1.png&quot; alt=&quot;Probability density function&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Cool. But we want to automatically establish this Hoare triple with an SMT solver.
How? We’ll get rid of probability. Adios!&lt;/p&gt;

&lt;h2 id=&quot;turning-sampling-into-non-determinism&quot;&gt;Turning sampling into non-determinism&lt;/h2&gt;

&lt;p&gt;The idea is that the SMT solver needs to only know a few &lt;em&gt;axioms&lt;/em&gt; about the probability distributions in order to construct the proof.
In our example, the proof relies on the obvious fact that $y \geq x$ with a probability of $2/3$.&lt;/p&gt;

&lt;p&gt;If we know this fact, we can transform the program into a non-deterministic version that &lt;em&gt;tracks probability of failure&lt;/em&gt;:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f_nondet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pick&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We now have a non-probabilistic program:
&lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt;  gets an arbitrary (non-deterministic) value between &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;3*x&lt;/code&gt;;
but we know that this may not be true with a probability of &lt;code class=&quot;highlighter-rouge&quot;&gt;1/3&lt;/code&gt;, which is stored in a new &lt;em&gt;ghost&lt;/em&gt; variable &lt;code class=&quot;highlighter-rouge&quot;&gt;w&lt;/code&gt;.
The transformation relies on the following insight:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;make whatever assumptions you want&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;but&lt;/em&gt; remember the probability with which your assumptions might fail&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;So now we can prove the above Hoare triple &lt;script type=&quot;math/tex&quot;&gt;\vdash_{\color{red}{1/3}} \{x &gt; 0\}  ~f(x)~ \{y \geq x\}&lt;/script&gt;  using the transformed, non-deterministic program instead:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(\underbrace{x &gt; 0}_{\text{pre}} \land \underbrace{x \leq y \leq 3x  \land w = 1/3}_{\text{encoding of } f_\textit{nondet}}) \Longrightarrow (\underbrace{y \geq x}_{\text{post}} \land \underbrace{w \leq \color{red}{1/3}}_{\text{failure prob.}})&lt;/script&gt;

&lt;h2 id=&quot;picking-the-right-axioms&quot;&gt;Picking the right axioms&lt;/h2&gt;

&lt;p&gt;In our example, we gave the SMT solver exactly the axiom it needs to know about the uniform distribution. 
But in general, we want to automatically discover the right axiom to get the proof to go through. 
Calvin’s insight was that we can see this as a &lt;em&gt;program synthesis&lt;/em&gt; problem!&lt;/p&gt;

&lt;p&gt;The idea is to use an &lt;em&gt;axiom family&lt;/em&gt; and synthesize the appropriate axiom from this family.
Check out this parameterized version of &lt;code class=&quot;highlighter-rouge&quot;&gt;f_nondet&lt;/code&gt; above:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f_synth&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pick&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;?1&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;?2&lt;/code&gt; are two unknown expressions that we want to synthesize; they define the assumption we are making.
Depending on what we choose, we will &lt;em&gt;incur&lt;/em&gt; a different probability of failure &lt;code class=&quot;highlighter-rouge&quot;&gt;w&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/probability2.png&quot; alt=&quot;Probability density function of axiom family&quot; /&gt;&lt;/p&gt;

&lt;p&gt;So now you can use your favorite program synthesis engine to synthesize values for the unknowns such that &lt;script type=&quot;math/tex&quot;&gt;y \geq x&lt;/script&gt; and $w \leq 1/3$. 
Say we pick &lt;code class=&quot;highlighter-rouge&quot;&gt;2*x&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;3*x&lt;/code&gt; for &lt;code class=&quot;highlighter-rouge&quot;&gt;?1&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;?2&lt;/code&gt;.
We get the following program:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f_synth_inst1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pick&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This satisfies our postcondition — that $y \geq  x$ — but with a failure probability of $2/3$, higher than our goal of $1/3$.&lt;/p&gt;

&lt;p&gt;Now check out this other instantiation where we set &lt;code class=&quot;highlighter-rouge&quot;&gt;?1&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;?2&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;3*x&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f_synth_inst2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pick&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This has a 0 probability of failure: &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt; always is between &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;3*x&lt;/code&gt; with a probability of 1. But it does not satisfy the postcondition, since &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt; may very well be less than &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The synthesizer should return the program &lt;code class=&quot;highlighter-rouge&quot;&gt;f_nondet&lt;/code&gt; above,
which sets &lt;code class=&quot;highlighter-rouge&quot;&gt;?1&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;?2&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;3*x&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;synthesis-problem&quot;&gt;Synthesis problem&lt;/h2&gt;

&lt;p&gt;To solve the synthesis problem above with an SMT solver,
we encode the problem in the form of &lt;script type=&quot;math/tex&quot;&gt;\exists.\forall .\varphi&lt;/script&gt;:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\exists ?_1, ?_2 . \forall x,y,z,w .&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(\underbrace{x &gt; 0}_{\text{pre}} \land \underbrace{?_1 \leq y \leq ?_2  \land w = 1 - (?_2-?_1)/3x }_{\text{encoding of } f_\textit{synth}}) \Longrightarrow (\underbrace{y \geq x}_{\text{post}} \land \underbrace{w \leq \color{red}{1/3}}_{\text{failure prob.}})&lt;/script&gt;

&lt;p&gt;The idea is we want to find ($\exists$) solutions to the unknowns $?_1$ and $?_2$
such that for any execution ($\forall$) where $x&amp;gt;0$ the postcondition holds and the failure probability is no more than $1/3$.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;That’s it. We’ve thrown probability away. 
Now you can reason about randomized algorithms with first-order logic.
But that’s not to say that solving the resulting formulas is easy!&lt;/p&gt;

&lt;p&gt;Our &lt;a href=&quot;http://pages.cs.wisc.edu/~aws/papers/popl19.pdf&quot;&gt;paper&lt;/a&gt; gives a full-blow, soundness-police-compliant view of this idea – and a lot of implementation details because some of these formulas involve non-linear arithmetic and quantifier alternation. We manage to automatically prove accuracy properties of some sophisticated algorithms from the differential privacy literature.
It’s really fascinating how far we can take SMT solvers.&lt;/p&gt;
&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:union-bound&quot;&gt;
      &lt;p&gt;Notation from union bound logic, a probabilistic Hoare logic due to &lt;a href=&quot;https://arxiv.org/abs/1602.05681&quot;&gt;Barthe et al.&lt;/a&gt; &lt;a href=&quot;#fnref:union-bound&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>Differentiable Programming: A Semantics Perspective</title>
   <link href="http://localhost:4000/2018/05/01/differentiable-programming/"/>
   <updated>2018-05-01T00:00:00-05:00</updated>
   <id>http://localhost:4000/2018/05/01/differentiable-programming</id>
   <content type="html">&lt;p&gt;So deep learning has taken the world by storm.
Frameworks for training deep neural networks, like &lt;a href=&quot;https://www.tensorflow.org/&quot;&gt;TensorFlow&lt;/a&gt;, allow you to construct so-called &lt;em&gt;differentiable programs&lt;/em&gt;.
The idea is that one can compute the derivative of some program (usually some neural net), and then use that to optimize its parameters.&lt;/p&gt;

&lt;p&gt;I wrote this post to introduce researchers in the verification and programming languages community to automatic differentiation of programs.
The assumption is that—extrapolating from myself here—you got into this field for the love of logic and discrete math (and an unhealthy aversion to continuous mathematics).&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;programming-language&quot;&gt;Programming language&lt;/h2&gt;
&lt;p&gt;Let’s consider a very simple programming language where there are no loops or conditions, just a sequence of assignment statements of the form:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;v_1 \gets c&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;v_1 \gets v_2 \times v_3&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;v_1 \gets v_2 + v_3&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;v_1 \gets cos(v_2)&lt;/script&gt;

&lt;p&gt;Here, $c$ is a real-valued constant and $v_i$ are real-valued program variables.
Any program $P$ in this language is assumed to have a single special input variable $x$ and an output variable $y$.&lt;/p&gt;

&lt;p&gt;$P$ is also assumed to be in &lt;em&gt;static single assignment&lt;/em&gt; (SSA) form—i.e., each variable gets assigned to at most once.
This is equivalent to &lt;em&gt;continuation-passing style&lt;/em&gt; (CPS). If you’ve used TensorFlow, the &lt;em&gt;computation graph&lt;/em&gt; that you construct there is effectively a program in SSA, where each graph node represents one variable’s assignment.&lt;/p&gt;

&lt;h2 id=&quot;example-program&quot;&gt;Example program&lt;/h2&gt;
&lt;p&gt;Note that programs in our language are functions in $\mathbb{R} \to \mathbb{R}$.
Consider the function $f(x) = x^2 + cos(x^2)$.
We can write this in our language as the program $P$ below:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align*}
v_1 &amp;\gets x \times x\\
v_2 &amp;\gets cos(v_1)\\
y &amp;\gets v_1 + v_2
\end{align*} %]]&gt;&lt;/script&gt;

&lt;p&gt;If you plot this function, you get the following spooky graph:
&lt;img src=&quot;http://localhost:4000/assets/graph.png&quot; alt=&quot;Graph of running example&quot; /&gt;&lt;/p&gt;

&lt;p&gt;If you remember your calculus, the partial derivative of a function $\frac{\partial f}{\partial x}$ is essentially the rate of change of the output $y$ as $x$ changes.
For our function $f$,&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{\partial f}{\partial x}(x) = 2x - 2x \times sin(x)&lt;/script&gt;

&lt;p&gt;Notice that  $\frac{\partial f}{\partial x}(0) = 0$,
since  $x = 0$ is a &lt;em&gt;stationary point&lt;/em&gt;, so the rate of change at that point is 0.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Technically, we’re computing total derivatives in this post, since we only have one input variable $x$, which I enforce for simplicity. The general methodology I lay out here easily extends to functions with multiple input arguments.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;language-semantics&quot;&gt;Language semantics&lt;/h2&gt;
&lt;p&gt;The semantics of our little language is standard.
A state $s$ of a program $P$ is a map from variables
to real numbers.
The function $\textit{post}$ below takes a program and a state $s$ and returns the state resulting from executing $P$:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;$\textit{post}(P_1;P_2, s) \triangleq \textit{post}(P_2,\textit{post}(P_1,s))$&lt;/li&gt;
  &lt;li&gt;$\textit{post}(v_1 \gets c, s) \triangleq s[v_1 \mapsto c]$&lt;/li&gt;
  &lt;li&gt;$\textit{post}(v_1 \gets v_2 \times v_3, s) \triangleq s[v_1 \mapsto s(v_2) \times s(v_3)]$&lt;/li&gt;
  &lt;li&gt;$\textit{post}(v_1 \gets v_2 + v_3, s) \triangleq s[v_1 \mapsto s(v_2) + s(v_3)]$&lt;/li&gt;
  &lt;li&gt;$\textit{post}(v_1 \gets cos(v_2), s) \triangleq s[v_1 \mapsto cos(s(v_2))]$&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Above, $P_1;P_2$ denotes sequential composition,
$s(v)$ denotes the value of $v$ in state $s$, and $s[v \mapsto c]$ denotes state $s$ but with $v$ mapping to the value $c$.&lt;/p&gt;

&lt;h2 id=&quot;forward-differentiation&quot;&gt;Forward differentiation&lt;/h2&gt;

&lt;p&gt;We will now extend the semantics such that evaluating $P$ on input $x$ not only returns $P(x)$, but also $\frac{\partial P}{\partial x}(x)$, the partial derivative of $P$ w.r.t. the input variable $x$.&lt;/p&gt;

&lt;p&gt;Below, we define the new semantics with a function $\partial\textit{post}$, where we keep track of two copies of the program variables, the variables $v_i$ and a new copy $\dot v_i$, which denotes the rate of change of $v_i$ w.r.t. the input $x$, i.e.,&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\dot v_i = \frac {\partial v_i}{\partial x}(x)&lt;/script&gt;

&lt;p&gt;Finally, when the program terminates with the new semantics, we can recover the variable $\dot y$, which will hold the value $\frac{\partial P}{\partial x}(x)$.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note that, by definition, $\dot x = 1$.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Sequential composition&lt;/strong&gt; For sequential composition, $P_1;P_2$, $\partial\textit{post}$ behaves just like $\textit{post}$.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Constant assignment&lt;/strong&gt; For the constant assignment $v_1 \gets c$,
we have&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\partial\textit{post}(v_1 \gets c, s) \triangleq s[v_1 \mapsto c][ \dot v_1 \mapsto 0]&lt;/script&gt;

&lt;p&gt;In other words, the rate of change of $v_1$ is zero, since it’s not dependent on $x$ in any way.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Addition&lt;/strong&gt; For addition, we have&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\partial\textit{post}(v_1 \gets v_2 + v_3, s) \triangleq s[v \mapsto s(v_1) + s(v_2)][ \dot v \mapsto s(\dot v_1) + s(\dot v_2)]&lt;/script&gt;

&lt;p&gt;That is, the rate of change of $v_1$ is the sum of the rates of change of $v_2$ and $v_3$.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Multiplication&lt;/strong&gt; For multiplication,&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\partial\textit{post}(v_1 \gets v_2 \times v_3, s) \triangleq s[v_1 \mapsto s(v_2) \times s(v_3)][\dot v_1 \mapsto \dot v_2 \times v_3 + v_2 \times \dot v_3]&lt;/script&gt;

&lt;p&gt;In other words, the rate of change of $v_1$ w.r.t. $x$ is the rate of change of $v_2$, scaled by $v_3$, plus the rate of change of $v_3$, scaled by $v_2$.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Trigonometric functions&lt;/strong&gt; For cosine, we have&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\partial\textit{post}(v_1 \gets cos(v_2), s) \triangleq s[v \mapsto cos(s(v_2))] [\dot v \mapsto \dot v_2 \times - sin(s(v_2))]&lt;/script&gt;

&lt;p&gt;This follows from the &lt;em&gt;chain rule&lt;/em&gt;, which says that the rate of change of $f(u)$ is the rate of change of $f$ scaled by the rate of change of its argument $u$.
You might remember that the derivative of $cos(x)$ is $-sin(x)$, so, following the chain rule, we simply scale $-sin(v_2)$ by $\dot v_2$.&lt;/p&gt;

&lt;h2 id=&quot;example-continued&quot;&gt;Example continued&lt;/h2&gt;

&lt;p&gt;Continuing our above example with the program $P$ encoding the function $f(x) = x^2 + cos(x^2)$,
we can now execute $P$ using our new semantics.
Say, we begin executing $P$ from the state where $x = 0$.
At the end of the execution, we will get a state
where $y = 1$, and $\dot y = 0$.&lt;/p&gt;

&lt;p&gt;Let’s step through the program one instruction at a time, maintaining both copies of the variables at every point along the way.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align*}
[x = 0, \dot x = 1, \ldots]\\
v_1 &amp;\gets x \times x\\
[v_1 = 0, \dot v_1 = 0, \ldots]\\
v_2 &amp;\gets cos(v_1)\\
[v_2 = 1, \dot v_2 = 0, \ldots]\\
y &amp;\gets v_1 + v_2\\
[y = 1, \dot y = 0, \ldots]\\
\end{align*} %]]&gt;&lt;/script&gt;

&lt;h2 id=&quot;notes&quot;&gt;Notes&lt;/h2&gt;

&lt;p&gt;I covered the simpler case of forward differentiation, which proceeds by executing the program in a forward manner. For functions with more than one input, it is more efficient to perform backward differentiation, which the popular &lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Backpropagation&quot;&gt;backpropagation&lt;/a&gt;&lt;/em&gt; algorithm is an instance of. Adapting the above semantics to backpropagation is not hard, it’s just messier, as we have to execute the program forward and then backward. Therefore, I decided to illustrate the forward mode only. For more information, I encourage you to read the excellent survey by &lt;a href=&quot;https://arxiv.org/abs/1502.05767&quot;&gt;Baydin et al.&lt;/a&gt;, which heavily influenced my presentation.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Thanks to Kartik Agaram, Ben Liblit, and David Cabana for catching typos and errors.&lt;/em&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Fairification: Making Unfair Programs Fair</title>
   <link href="http://localhost:4000/2017/05/01/debiasing/"/>
   <updated>2017-05-01T00:00:00-05:00</updated>
   <id>http://localhost:4000/2017/05/01/debiasing</id>
   <content type="html">&lt;p&gt;Over the past year, we have been exploring the notion of &lt;a href=&quot;http://pages.cs.wisc.edu/~aws/papers/fatml16.pdf&quot;&gt;&lt;em&gt;algorithmic fairness&lt;/em&gt; from a PL/verification perspective&lt;/a&gt;.
Today I’m going to talk about a new paper we have that is appearing at CAV 2017: &lt;a href=&quot;http://pages.cs.wisc.edu/~aws/papers/cav17.pdf&quot;&gt;&lt;em&gt;Repairing Decision-making Programs under Uncertainty&lt;/em&gt;&lt;/a&gt;, with Samuel Drews and Loris D’Antoni.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;algorithmic-fairness&quot;&gt;Algorithmic fairness&lt;/h2&gt;

&lt;p&gt;With software rapidly overtaking sensitive decision-making processes, like policing and sentencing, many people have been very concerned with unfairness in automated decision-making.
The past year or so has seen lots of attention in this space, for example:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.propublica.org/article/machine-bias-risk-assessments-in-criminal-sentencing&quot;&gt;ProPublica’s investigation&lt;/a&gt; uncovered bias against African Americans in software used for risk assessment in courtrooms (including here in the state of  Wisconsin), which judges can use to inform their decisions.&lt;/li&gt;
  &lt;li&gt;Cathy O’Neil published &lt;a href=&quot;https://www.amazon.com/Weapons-Math-Destruction-Increases-Inequality/dp/0553418815&quot;&gt;&lt;em&gt;Weapons of Math Destruction&lt;/em&gt;&lt;/a&gt;, an excellent book warning about a world run by unregulated, opaque algorithms.&lt;/li&gt;
  &lt;li&gt;The pre-Trump White House released a &lt;a href=&quot;https://obamawhitehouse.archives.gov/sites/default/files/whitehouse_files/microsites/ostp/NSTC/preparing_for_the_future_of_ai.pdf&quot;&gt;report&lt;/a&gt; on AI that explicitly warned about encoding discrimination in automated decision-making.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And this is just part of the popular coverage of algorithmic fairness.
In our unpopular (academic) world, the action has been primarily in the machine learning arena, where researchers have been studying ways to learn fair classifiers, for certain definitions of fairness.&lt;/p&gt;

&lt;h2 id=&quot;unfair-programs-well-fairify-them-for-you&quot;&gt;Unfair programs? We’ll fairify them for you!&lt;/h2&gt;

&lt;p&gt;While algorithmic unfairness is an alarming
issue with potentially large-scale negative effects,
I believe that the move to algorithmic decision-making
has a silver lining: We can rigorously
reason about programs, debug them, and fix them.&lt;/p&gt;

&lt;p&gt;In our work, we went after the following problem:
Say we’re given a program that decides
whether to hire a job applicant
that is unfair (more on what that means in a bit).
By program I mean a piece of code that
is maybe a machine learning model, a
script distilled from the wisdom of a VP,
an SQL query written by a data scientist, whatever!
Our view is that such a program is probably
not designed to be blatantly unfair.
So what we’d like to do is to tweak it a little
bit and make it fair—I like to (unofficially)
call this process &lt;em&gt;fairification&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The main question that I’ve avoided
so far is &lt;em&gt;how do you formalize fairness?!&lt;/em&gt;
This is a deep philosophical problem.
But computer scientists love to formalize
the unformalizable!
Recent work in the area has proposed
several definitions.
Let’s look at the one from &lt;a href=&quot;https://arxiv.org/pdf/1412.3756.pdf&quot;&gt;Feldman et al.&lt;/a&gt;,
which formalizes  the 80–20
rule of thumb from the Equality of Employment
Commission here in the US:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{Pr [hire | minority]}
{Pr [hire | \neg minority]} &gt; 0.8&lt;/script&gt;

&lt;p&gt;The intuition is simple: the probability
of hiring from the minority applicant pool
is at least 80% that of hiring from the non-minority pool—assuming a binary split
of the population.&lt;/p&gt;

&lt;p&gt;OK, great. We’ve fully formalized
fairness, leaving no room for philosophy.&lt;/p&gt;

&lt;p&gt;For an ultra-simple illustration,
say the program we have is the following:
It only takes one thing about the applicant,
the rank of the college they attended.
If the applicant attended a top-ten
school, then, good for them, they get hired!&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;urank&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;urank&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Is this program fair?
Well, it depends on the population!
We will represent the population as
a probabilistic model:
10% of the population are minorities;
non-minorities go to schools ranked 10
on average; minorities go to schools
ranked 15 on average (here $min$
is 1 for minority and 0 for non-minority).&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;min \sim Bernoulli(0.1)\\
urank \sim Gaussian(10 + 5*min, 10)&lt;/script&gt;

&lt;p&gt;With this population model,
this program is unfair; on the above
fairness definition, the ratio
evaluates to ~0.6.
How do we fix it?&lt;/p&gt;

&lt;p&gt;Our approach proceeds like this:
First, we characterize a class
of programs using a &lt;em&gt;sketch&lt;/em&gt;
(I talked about sketches in the last &lt;a href=&quot;/2017/04/24/synthesis-primer/&quot;&gt;post&lt;/a&gt;).
One possible sketch here is the following,
where &lt;code class=&quot;highlighter-rouge&quot;&gt;??&lt;/code&gt; are unknowns.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;urank&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;??&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;urank&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;??&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Essentially, the sketch characterizes
a family of programs
(ML people call this a hypothesis class).
In this case, we’ve knocked out
the constants in the program and
we’re hoping to replace them with new ones
to make it fair.
The same idea can be extended to not only
constants, but also instructions and branching.
The sketch encodes our &lt;em&gt;repair model&lt;/em&gt;,
the various ways in which we can tweak
the original program.&lt;/p&gt;

&lt;p&gt;Now, we want to find a completion of this
sketch such that&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1) The completion is &lt;em&gt;semantically close&lt;/em&gt; to the original program.
(Semantic closeness  just means that
the two programs agree on most inputs.)&lt;/li&gt;
  &lt;li&gt;2) The completion is fair according
to the definition above.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The idea is that we want to give the program a small &lt;em&gt;nudge&lt;/em&gt; to make it fair.
One possible completion is the following:&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;urank&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;urank&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This program happens to be fair, per the above definition, and is semantically close to the original program.
In a sense, we kept increasing the upper bound on the college ranking until we got a fair program. Our tool would find such completion.&lt;/p&gt;

&lt;p&gt;Before I discuss how we actually do the &lt;em&gt;fairifcation&lt;/em&gt;,
I have to state that I do not claim this is the best &lt;em&gt;debiasing&lt;/em&gt; of our program or
that that fairness conditions I used in this example is the most desirable in this setting.
I simply intended this combination for illustration.&lt;/p&gt;

&lt;h2 id=&quot;fairification-with-program-synthesis&quot;&gt;Fairification with program synthesis&lt;/h2&gt;

&lt;p&gt;The approach we used is a new method for
program synthesis.
Most work in the program synthesis literature
attempts to find a program that satisfies a specification.
Here, our specification is a probabilistic one.
Our technique uses SMT solvers, fancy data structures,
and a sprinkle of statistical learning theory for good measure.
It traverses the space of programs
and finds fair programs that are close to the original unfair one.
Our technique can take an arbitrary fairness
definition in a syntactic language that
is expressions over probabilities of events, like the
80–20 rule we saw above.&lt;/p&gt;

&lt;p&gt;For details, I invite you to read our &lt;a href=&quot;http://pages.cs.wisc.edu/~aws/papers/cav17.pdf&quot;&gt;paper&lt;/a&gt;.
For a quick synthesis primer, I invite
you to read an earlier &lt;a href=&quot;/2017/04/24/synthesis-primer/&quot;&gt;post&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;looking-forward&quot;&gt;Looking forward&lt;/h2&gt;

&lt;p&gt;Most of the recent works have focused on unfairness in automation of bureaucratic processes, like loans, hiring, and others.
But fairness and unfairness extend to any other area where we interact with software. In the near future, it appears that  we’ll be interacting with robots, self-driving cars, and other autonomous agents. What does fairness mean there?&lt;/p&gt;

&lt;p&gt;I believe there’s lots of interesting and important
work to be done by the programming languages
and verification communities on the issue
of fair programs:
&lt;em&gt;How do we debug unfair programs?
There are lots of algorithms introduced
for fair classification; can we build verified implementations? Can we build programming-language support for reasoning
about fairness in data analysis environments?&lt;/em&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>A Program Synthesis Primer</title>
   <link href="http://localhost:4000/2017/04/24/synthesis-primer/"/>
   <updated>2017-04-24T00:00:00-05:00</updated>
   <id>http://localhost:4000/2017/04/24/synthesis-primer</id>
   <content type="html">&lt;p&gt;My colleague Somesh Jha recently asked me to give a lecture on &lt;em&gt;program synthesis&lt;/em&gt; to his class.
As I prepared my notes, I realized that a single lecture is long enough to formally define the problem and code up some cool examples
that demonstrate the process.
This post contains the notes and code I used in class.
I go through two simple examples in this post; the full code is on &lt;a href=&quot;https://github.com/barghouthi/704examples/tree/master/synthesis&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;what-is-program-synthesis-anyways&quot;&gt;What is program synthesis anyways?&lt;/h2&gt;

&lt;p&gt;In the fields of programming languages and verification,
the traditional problem of program synthesis involves
constructing a program from a high-level mathematical specification.
For example, suppose you want to write a program
that computes the factorial of a number  $n \gt 1$.
You start with the mathematical definition of factorial,
$ n! $, and you gradually massage
it—rewrite it using your knowledge of the properties of
factorial and mathematics—until you get to an executable program.&lt;/p&gt;

&lt;p&gt;While lofty in its goals and rich in its tradition, this synthesis approach—called &lt;em&gt;deductive synthesis&lt;/em&gt;—has had limited success.
Simply, mathematical specifications are hard to write,
and turning a specification to a program is very hard to automate.&lt;/p&gt;

&lt;h2 id=&quot;combinatorial-synthesis&quot;&gt;Combinatorial synthesis&lt;/h2&gt;

&lt;p&gt;Recently, researchers have been looking at forms
of synthesis that are simpler to automate.
The style of synthesis I will focus on here is
the one pioneered in the &lt;a href=&quot;https://people.csail.mit.edu/asolar/papers/thesis.pdf&quot;&gt;Sketch&lt;/a&gt; project.
The idea is that we start with a &lt;em&gt;reference implementation&lt;/em&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;p_naive&lt;/code&gt;.
Think of this as the naive solution of a problem
that you’re sure works correctly, but that you won’t put into production, perhaps because it’s pretty inefficient.
Your goal is to find a program &lt;code class=&quot;highlighter-rouge&quot;&gt;p_smart&lt;/code&gt;
that is equivalent to &lt;code class=&quot;highlighter-rouge&quot;&gt;p_naive&lt;/code&gt;,
but that is more efficient and hard to get right.&lt;sup id=&quot;fnref:fn-compiler&quot;&gt;&lt;a href=&quot;#fn:fn-compiler&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;For illustration, let’s look at an extremely simple example.
The naive program is the following,
where for simplicity we assume all &lt;code class=&quot;highlighter-rouge&quot;&gt;ints&lt;/code&gt; are bitvectors with an 8-bit width.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p_naive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You, as a smart (but not very smart) programmer, think
that you can do better by writing a program of the following
form, but you’re not sure what to place in the &lt;code class=&quot;highlighter-rouge&quot;&gt;??&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p_smart&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;??&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shift&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In a sense, &lt;code class=&quot;highlighter-rouge&quot;&gt;p_smart&lt;/code&gt; represents a family
of programs—all possible instantiations of the &lt;em&gt;hole&lt;/em&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;??&lt;/code&gt;.
Of course, the right completion here is replacing
the hole with &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;automating-synthesis&quot;&gt;Automating synthesis&lt;/h2&gt;

&lt;p&gt;So how do we automatically find the value of &lt;code class=&quot;highlighter-rouge&quot;&gt;??&lt;/code&gt;
that makes &lt;code class=&quot;highlighter-rouge&quot;&gt;p_smart&lt;/code&gt; equivalent to &lt;code class=&quot;highlighter-rouge&quot;&gt;p_naive&lt;/code&gt;.
Easy! There are $ 2^8 $ different instantiations 
of &lt;code class=&quot;highlighter-rouge&quot;&gt;??&lt;/code&gt;, so we enumerate
them until we find the right one.
In general this incurs a combinatorial explosion.
We cannot avoid the combinatorial problem,
but it turns out we can neatly characterize the
search space as a formula that we can give to an efficient
off-the-shelf solver—as we will see in a bit.&lt;/p&gt;

&lt;p&gt;First, let’s try to gradually formalize the problem.
We will use the variable &lt;code class=&quot;highlighter-rouge&quot;&gt;h&lt;/code&gt;
to denote the hole &lt;code class=&quot;highlighter-rouge&quot;&gt;??&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Definition 1&lt;/strong&gt; &lt;em&gt;Find a value&lt;/em&gt; for &lt;code class=&quot;highlighter-rouge&quot;&gt;h&lt;/code&gt;
such that &lt;em&gt;for all values&lt;/em&gt; of &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;p_naive(x) == p_smart(x)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Definition 2&lt;/strong&gt;  We can think of &lt;code class=&quot;highlighter-rouge&quot;&gt;h&lt;/code&gt; as
an input to &lt;code class=&quot;highlighter-rouge&quot;&gt;p_smart&lt;/code&gt;.
So, our goal is really to
&lt;em&gt;find a value&lt;/em&gt; for &lt;code class=&quot;highlighter-rouge&quot;&gt;h&lt;/code&gt;
such that &lt;em&gt;for all values&lt;/em&gt; of &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;,
&lt;code class=&quot;highlighter-rouge&quot;&gt;p_naive(x) == p_smart(x,h)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Definition 3&lt;/strong&gt; Now, we can view a program, say, &lt;code class=&quot;highlighter-rouge&quot;&gt;p_naive&lt;/code&gt;,
as a logical relation $ \varphi_n(x,y) $
over its input and output variables, $ x $ and $ y $.
The idea is that the relation is true if and only
if &lt;code class=&quot;highlighter-rouge&quot;&gt;p_naive(x) == y&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So, our goal is really to find
&lt;em&gt;find a value&lt;/em&gt; for $ h $
such that &lt;em&gt;for all values&lt;/em&gt; of  $ x $ and $y$,
we have
$ \varphi_n(x,y) \iff \varphi_s(x,h,y) $
is true.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Final definition&lt;/strong&gt;
Finally, we are ready to state the problem logically.
Find a satisfying assignment of the following formula
&lt;script type=&quot;math/tex&quot;&gt;\forall x,y \ldotp \varphi_n(x,y) \iff \varphi_s(x,h,y)&lt;/script&gt;
Notice that the variable $ h $
is &lt;em&gt;free&lt;/em&gt;. Therefore, any satisfying assignment
of this formula is only over $ h $.&lt;/p&gt;

&lt;p&gt;At this point, we have completely
reduced the synthesis problem to solving a logical
formula. We can do this with an SMT solver like &lt;a href=&quot;https://github.com/Z3Prover/z3&quot;&gt;Z3&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;a-detailed-example&quot;&gt;A detailed example&lt;/h2&gt;

&lt;p&gt;We can now apply the above
process to encode &lt;code class=&quot;highlighter-rouge&quot;&gt;p_smart&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;p_naive&lt;/code&gt; as formulas.
We will encode them in the first-order theory of bitvectors,
which has all the standard operations we care about.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\varphi_n(x,y) \equiv y = x * 2&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\varphi_s(x,y,h) \equiv y = x &lt;&lt; h %]]&gt;&lt;/script&gt;

&lt;p&gt;We will now encode those in Z3
using its Python API
as follows.&lt;/p&gt;

&lt;p&gt;First, we define all the variables
as 8-bitvectors.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;The code for this example is available
on &lt;a href=&quot;http://github.com/barghouthi/704examples/blob/master/synthesis/synth.py&quot;&gt;GitHub&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BitVec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'x'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BitVec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'y'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BitVec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'h'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Next, we encode $ \varphi_n $ and $ \varphi_s $:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;phi_n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;phi_s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Finally, we are ready to invoke Z3:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# first, encode the universally quantified formula&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# (the == symbol is if and only if)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;encoding&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ForAll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;phi_n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;phi_s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# second, call Z3 and check if there is a model&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Solver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;encoding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;check&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# print the model (i.e., the value of h)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If you run this code, you will get the output &lt;code class=&quot;highlighter-rouge&quot;&gt;[h = 1]&lt;/code&gt;,
just as expected!&lt;/p&gt;

&lt;h2 id=&quot;test-driven-synthesis&quot;&gt;Test-driven synthesis&lt;/h2&gt;

&lt;p&gt;The approach presented above works over two programs:
it tries to find a program that is &lt;em&gt;equivalent&lt;/em&gt; to
some reference implementation.
Instead of writing a full-blown reference implementation,
we will now just write some test cases,
and find a program that passes all of them.
You could think of this as test-driven development on steroids!&lt;/p&gt;

&lt;p&gt;Say we want to write a function that, given
bitvector &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;, returns a bitvector &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt; that is 1  in the
position of the first 0 from the right occuring in &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;, and 0 everywhere else.&lt;sup id=&quot;fnref:fn-sketch&quot;&gt;&lt;a href=&quot;#fn:fn-sketch&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;For example,&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# test 1&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mo&quot;&gt;00000000&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mo&quot;&gt;00000001&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# test 2&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mo&quot;&gt;00000011&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mo&quot;&gt;00000100&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# test 3&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mo&quot;&gt;00000010&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mo&quot;&gt;00000001&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Suppose you have the following hunch on how to write
such a program efficiently:&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;??&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;??&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Here &lt;code class=&quot;highlighter-rouge&quot;&gt;~&lt;/code&gt; is bitwise not and &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt; is bitwise and.
Our goal is to find solutions to the two holes
that result in our desired program.&lt;/p&gt;

&lt;p&gt;Just as before, we encode the program as a logical relation:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\varphi_s \equiv y = (\sim(x + h_1))\ \&amp;\ (x + h_2) %]]&gt;&lt;/script&gt;

&lt;p&gt;Note how we encoded the two holes as two variables.&lt;/p&gt;

&lt;p&gt;Similarly, we can encode the test cases as a relation:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\varphi_t \equiv  t_1 \lor t_2 \lor t_3&lt;/script&gt;

&lt;p&gt;where&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;t_1 \equiv x = 0 \land y = 1\\
t_2 \equiv x = 3 \land y = 4\\
t_3 \equiv x = 2 \land y = 1&lt;/script&gt;

&lt;p&gt;Finally, we solve the following formula:
&lt;script type=&quot;math/tex&quot;&gt;\forall x, y \ldotp \varphi_t \Rightarrow \varphi_s&lt;/script&gt;
Observe that we have an implication and not an equivalence
between the two relations.
Intuitively, the relation defined by the test cases
is small and does not define the behavior other than for
the 3 test cases we’ve supplied.
So what we’re looking for is a program &lt;code class=&quot;highlighter-rouge&quot;&gt;p_smart&lt;/code&gt;
where all
test cases appear in (or are a subset of) its relation.&lt;/p&gt;

&lt;p&gt;Let’s encode this in Z3.
The process is similar to what we saw above:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;The code for this example is available
on &lt;a href=&quot;http://github.com/barghouthi/704examples/blob/master/synthesis/synth_test.py&quot;&gt;GitHub&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;phi_s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;h1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;h2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;And&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;t2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;And&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;t3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;And&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;phi_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Or&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;encoding&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ForAll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Implies&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;phi_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;phi_s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Solving the formula &lt;code class=&quot;highlighter-rouge&quot;&gt;encoding&lt;/code&gt;,
we get &lt;code class=&quot;highlighter-rouge&quot;&gt;[h2 = 1, h1 = 0]&lt;/code&gt;, which results in a correct program.&lt;/p&gt;

&lt;p&gt;Since we are dealing with test cases,
the test cases we supply may be insufficient to force the SMT
solver to find the right program; in such case,
you can supply more tests.
For example, if I just give Z3 test 3, on my machine I get
&lt;code class=&quot;highlighter-rouge&quot;&gt;[h2 = 15, h1 = 14]&lt;/code&gt;, which is incorrect (check it).&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;We looked at a combinatorial form of program synthesis, where we define the search space as a program with holes.
You might wonder how to encode control-flow, and not only holes that
are replaced with consants. A great paper to read is &lt;a href=&quot;http://www.csl.sri.com/users/tiwari/papers/pldi2011-bitvector.pdf&quot;&gt;Synthesis of Loop-free Programs&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The idea of searching the space of programs has recently
been explored in a wide array of settings. It turns out
that handing the problem to the SMT solver is not always the right
way to go; sometimes a custom enumeration algorithm outperforms
SMT solvers. SMT solvers, however, are very good at finding
&lt;em&gt;magic constants&lt;/em&gt;, which simple enumeration may never get to.
So, in bit-twiddling problems, symbolic encodings like the one shown here are the way to go.&lt;/p&gt;
&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:fn-compiler&quot;&gt;
      &lt;p&gt;“But this is what an optimizing compiler does!” you protest. Yes! But here we are taking a &lt;em&gt;combinatorial&lt;/em&gt; approach: a compiler applies a fixed set of tricks to get to an efficient program; here we will manually define a space of programs, and search it exhaustively until we find the right one. In some sense, we are doing &lt;em&gt;superoptimization&lt;/em&gt;. &lt;a href=&quot;#fnref:fn-compiler&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:fn-sketch&quot;&gt;
      &lt;p&gt;Example borrowed from Sketch project and found through Loris D’Antoni’s notes. &lt;a href=&quot;#fnref:fn-sketch&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
 </entry>
 

</feed>
